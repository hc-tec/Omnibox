# V5.0 架构文档补充任务

## 任务概述

**创建日期**: 2025-11-16
**任务目标**: 补充 V5.0 架构文档中缺失的工程化细节，提升架构可落地性和可靠性
**相关文档**: `.agentdocs/langgraph-v5.0-flexible-agent-architecture.md`

## 现状分析

### 已完成内容
- ✅ 整体架构设计（AI IDE 模式借鉴、工具库扩展、流程优化、数据流改进）
- ✅ 私有数据工具三层架构设计
- ✅ 6 个阶段的实施路线图（14天）
- ✅ 风险评估与成功指标

### 识别的关键问题

#### 1. 工具契约缺失（Critical）
**位置**: langgraph-v5.0-flexible-agent-architecture.md:343-354,444-458

**问题描述**:
- `search_data_sources`/`filter_data` 只给出伪代码，缺少明确的输入输出字段
- 缺少 Schema 定义、分页/排序、容量上限
- 时区/时间格式未统一
- 错误码和幂等/重试约定未定义
- `filter_data` 默认全量加载到内存，缺少大数据量防护与类型约束

**影响**:
- Agent 无法准确理解工具能力边界
- 实现时各工具标准不一致
- 大数据量场景下可能 OOM
- 错误处理和重试逻辑无据可依

#### 2. 私有数据与授权策略不足（Critical）
**位置**: langgraph-v5.0-flexible-agent-architecture.md:325-337,400-437

**问题描述**:
- 仅返回 `auth_status` 字段，未定义鉴权来源
- Token 生命周期管理缺失
- 跨租户隔离策略未定义
- 权限降级/拒绝时的回退链路未设计
- 日志红线和敏感数据遮罩策略缺失

**影响**:
- 工具调用可能越权或泄漏私有数据
- 多租户环境下数据隔离风险
- 审计与合规要求无法满足
- Token 过期后无法自动刷新

#### 3. 知识图谱设计缺少落地细节（High）
**位置**: langgraph-v5.0-flexible-agent-architecture.md:1325-1327,1748-1779,2111

**问题描述**:
- 未说明存储介质（内存/持久化）
- 同步与并发控制策略缺失
- TTL/容量治理未设计
- 血缘更新失败的回滚策略未定义
- 如何与 V4.4 StashReference/外部存储对齐未说明
- "Python dict+list" 假设在长会话/多并发下易失控或丢数据

**影响**:
- 长会话场景下可能内存溢出
- 并发场景下可能数据竞态
- 知识图谱无法持久化，重启后丢失
- 与现有数据流不兼容

#### 4. 可靠性与测试设计缺失（High）
**位置**: langgraph-v5.0-flexible-agent-architecture.md:1565-1579,1887-1890,1988-1994

**问题描述**:
- 缺少错误分类与重试/降级矩阵
- 幂等保障未设计
- 超时与速率限制未定义
- 验收用例主要是正向 Happy Path
- 缺少空结果、部分失败、授权拒绝、数据量爆炸、模型输出异常等覆盖

**影响**:
- 生产环境稳定性无法保障
- 异常场景下用户体验差
- 无法支撑上线质量
- 缺少回归测试基准

#### 5. 轻量模式语义不明确（Medium）
**问题描述**:
- 存储/缓存策略未明确
- 可观测性要求未定义
- 错误处理流程不清晰
- Planner 协议未说明
- 与标准流程的切换条件模糊

**影响**:
- 实现时对轻量模式理解不一致
- 无法判断何时应该使用轻量模式
- 调试和监控困难

#### 6. 阶段目标需要重排（Medium）
**问题描述**:
- P0/P1 中未包含 `compare`/`aggregate` 等核心对比场景
- 每阶段缺少功能验收标准
- 缺少回退开关设计

**影响**:
- 早期版本无法支撑对比分析需求
- 阶段性验收标准不明确
- 出现问题时无法快速回退

## 方案设计

### 整体策略

采用**分层递进式补充**策略：
1. **契约层**: 先定义所有工具的严格 Spec
2. **安全层**: 设计统一的授权/隐私治理方案
3. **存储层**: 明确知识图谱与存储方案
4. **流程层**: 明确轻量模式语义与切换条件
5. **实施层**: 重排阶段目标，补充验收标准
6. **质量层**: 补全可靠性与测试设计

### 详细方案

#### 1. 工具契约规范

**新增章节**: `4.4 工具契约规范 (Tool Contract Specification)`

**内容结构**:
```markdown
## 4.4 工具契约规范

### 4.4.1 契约定义规范
- 输入参数 Schema (JSON Schema)
- 输出结果 Schema (JSON Schema)
- 容量限制 (分页、最大行数、字段数、嵌套深度)
- 时间格式 (统一使用 ISO 8601)
- 错误码定义 (E001-E999 分类体系)
- 幂等性保障 (基于 request_id)
- 超时设置 (默认 30s，可配置)

### 4.4.2 search_data_sources 完整契约
### 4.4.3 filter_data 完整契约
### 4.4.4 fetch_private_data 完整契约
### 4.4.5 其他工具契约
### 4.4.6 错误码规范
```

**关键设计点**:
- 统一使用 JSON Schema 定义入参/出参
- `filter_data` 增加：
  - `limit` 参数（默认 100，最大 1000）
  - `offset` 参数支持分页
  - `sample_mode`: "first_n" | "random" | "stratified"
  - `max_total_size`: 10MB 限制
- 错误码分类：
  - E1xx: 参数错误
  - E2xx: 授权错误
  - E3xx: 数据源错误
  - E4xx: 容量超限
  - E5xx: 系统错误

#### 2. 授权与隐私治理

**新增章节**: `4.5 授权与隐私治理 (Authorization & Privacy Governance)`

**内容结构**:
```markdown
## 4.5 授权与隐私治理

### 4.5.1 OAuth Token 管理
- Token 存储：加密存储在 services/auth_service
- Token 刷新：过期前 5 分钟自动刷新
- Token 撤销：用户主动断开或检测到异常时撤销
- 生命周期：access_token 2h，refresh_token 30d

### 4.5.2 跨租户数据隔离
- 租户识别：context.user_id 作为隔离键
- 查询过滤：所有私有数据查询自动加 user_id 过滤
- 缓存隔离：缓存 key 包含 user_id 前缀
- 日志隔离：审计日志包含 user_id 和 tenant_id

### 4.5.3 敏感数据遮罩
- PII 字段检测：email, phone, id_card, address
- 遮罩规则：phone 显示前 3 后 4，中间 * 替换
- 日志脱敏：自动检测并遮罩 PII 字段
- 返回最小化：仅返回 Agent 所需字段

### 4.5.4 权限拒绝与降级
- 未授权处理：返回 E201 错误码 + 授权引导链接
- Token 过期：自动刷新，失败后提示重新授权
- 权限不足：返回 E203 错误码 + 缺少权限说明
- 降级策略：私有数据失败时提示使用公开数据

### 4.5.5 审计日志要求
- 记录内容：user_id, tool_name, data_source, timestamp, result_status
- 敏感操作：私有数据访问、用户笔记搜索
- 保留期限：180 天
- 日志红线：禁止记录原始数据内容、token、密码
```

#### 3. 知识图谱与存储方案

**新增章节**: `5.4 知识图谱存储方案 (Knowledge Graph Storage)`

**内容结构**:
```markdown
## 5.4 知识图谱存储方案

### 5.4.1 存储介质选择
- **P0 阶段**：内存存储（GraphState 中的 knowledge_graph 字段）
  - 优点：实现简单，延迟低
  - 限制：会话结束后丢失，单会话容量限制 10MB

- **P2 阶段**：混合存储（内存 + Redis）
  - 热数据：最近 1h 的图谱保留在内存
  - 温数据：1h-24h 的图谱存储在 Redis，TTL 24h
  - 冷数据：24h 以上归档到 PostgreSQL，保留 7 天

- **P3 阶段**：图数据库（Neo4j/ArangoDB）
  - 支持复杂查询（多跳关系、子图匹配）
  - 支持知识图谱持久化和版本管理

### 5.4.2 容量与 TTL 治理
- 节点数量上限：单会话 1000 节点
- 边数量上限：单会话 5000 边
- 单节点属性大小：最大 1MB
- TTL 策略：
  - 内存图谱：会话结束后清理
  - Redis 图谱：24h 后过期
  - PostgreSQL 归档：7 天后清理

### 5.4.3 并发控制
- 读写锁：基于 asyncio.Lock 保护图谱修改
- 乐观锁：使用 version 字段检测冲突
- 事务支持：图谱更新与 data_stash 更新原子性

### 5.4.4 失败回滚策略
- 快照机制：每次修改前保存图谱快照
- 回滚条件：数据写入失败、图谱验证失败
- 回滚操作：恢复到上一个快照状态
- 最多保留：最近 5 个快照

### 5.4.5 与 V4.4 兼容性
- StashReference 兼容：
  - knowledge_graph 中的 data_id 与 StashReference.data_id 一致
  - 通过 data_id 可回溯到原始 StashReference
- 外部存储对接：
  - data_store.load(data_id) 获取原始数据
  - data_store.save(data_id, data) 更新数据
- 迁移路径：
  - P0: 仅在 GraphState 中增加 knowledge_graph 字段
  - P1: 逐步将 data_stash 中的引用关系迁移到图谱
```

#### 4. 轻量模式语义明确

**修订章节**: `5.2 轻量模式优化 (Lightweight Mode)`

**补充内容**:
```markdown
### 5.2.3 轻量模式语义定义

**触发条件**:
1. 探索类工具（search_data_sources, preview_data）
2. 单步任务（无依赖的简单查询）
3. Planner 显式标记 `lightweight: true`

**流程简化**:
1. 跳过 DataStasher（直接写入 working_memory）
2. 跳过 Reflector（不进行质量检查）
3. 跳过 KnowledgeGraph 更新（不构建关系）

**存储策略**:
- working_memory: 最多保留 50 条记录，FIFO 淘汰
- 不写入 data_stash（节省持久化开销）
- 不创建 DataReference（避免血缘追踪开销）

**缓存策略**:
- search_data_sources: 缓存 1h（按 query hash）
- preview_data: 缓存 5min（按 data_id + limit）
- 缓存介质：内存（LRU，最大 100 条）

**可观测性**:
- 日志前缀：`[LIGHTWEIGHT]`
- 监控指标：lightweight_mode_count, lightweight_cache_hit_rate
- Trace 标签：`mode=lightweight`

**错误处理**:
- 轻量模式失败时，不自动重试
- 返回错误给 Planner，由 Planner 决定是否切换到标准模式
- 错误信息包含：`lightweight_mode: true, suggest_full_mode: true`

**切换到标准模式的条件**:
1. Planner 发现需要数据持久化（后续步骤依赖此数据）
2. 数据量超过 working_memory 容量（50 条）
3. 需要进行数据质量检查（如用户笔记搜索）
4. 需要构建知识图谱关系

**Planner 协议**:
```json
{
  "plan": [
    {
      "tool_name": "search_data_sources",
      "execution_mode": "lightweight",  // 新增字段
      "reason": "探索阶段，无需持久化"
    }
  ]
}
```
```

#### 5. 重排阶段目标

**修订章节**: `8. 实施路线图 (Implementation Roadmap)`

**调整内容**:

```markdown
### 阶段 P0：核心工具与基础流程（3天）
**目标**: 建立最小可用系统
- search_data_sources (完整契约)
- filter_data (完整契约，含分页/采样)
- compare_data (新增，支持对比场景)
- ask_user_clarification
- 轻量模式 POC（仅 search_data_sources）

**验收标准**:
- [ ] 可通过自然语言查找数据源（准确率 > 80%）
- [ ] 可对数据进行筛选（支持 5 种以上条件类型）
- [ ] 可对比两个数据集（输出差异报告）
- [ ] 遇到歧义时可主动询问用户
- [ ] search_data_sources 使用轻量模式，响应时间 < 2s

**回退开关**: `ENABLE_V5_CORE_TOOLS=false` 回退到 V4.4

---

### 阶段 P1：私有数据 + 高级分析（3天）
**目标**: 支持私有数据访问和聚合分析
- fetch_private_data (完整契约 + 授权治理)
- search_user_notes
- aggregate_data (新增，支持聚合统计)
- 授权与隐私治理（OAuth Token 管理、数据隔离、脱敏）
- 错误分类与重试机制

**验收标准**:
- [ ] 可访问私有数据源（B站收藏、GitHub Starred）
- [ ] 授权失败时返回引导链接
- [ ] Token 过期时自动刷新
- [ ] 跨租户数据完全隔离（通过测试验证）
- [ ] 可对数据进行聚合统计（count, sum, avg, group_by）
- [ ] 敏感数据自动遮罩（PII 检测覆盖率 > 95%）

**回退开关**: `ENABLE_V5_PRIVATE_DATA=false` 降级为仅公开数据

---

### 阶段 P2：知识图谱 + 完整轻量模式（4天）
**目标**: 构建数据血缘和关系网络
- get_user_favorites
- preview_data
- extract_insights
- 知识图谱存储（内存 + Redis 混合存储）
- 完整轻量模式（所有探索类工具）
- 并发控制与失败回滚

**验收标准**:
- [ ] 知识图谱可追踪数据血缘（3 跳以内）
- [ ] 知识图谱可持久化到 Redis（24h TTL）
- [ ] 轻量模式覆盖所有探索类工具
- [ ] 图谱更新失败时可回滚
- [ ] 并发场景下数据一致性（10 并发测试通过）

**回退开关**: `ENABLE_V5_KNOWLEDGE_GRAPH=false` 禁用知识图谱

---

### 阶段 P3：多步规划 + Web 能力（2天）
**目标**: 支持复杂多步任务
- fetch_web_content
- ExecutionPlan 多步规划
- 依赖解析（StashReference）
- 并行执行优化

**验收标准**:
- [ ] 可执行 3 步以上的复杂任务
- [ ] 可正确处理步骤依赖关系
- [ ] 支持并行执行（2+ 工具并行）
- [ ] Web 内容抓取成功率 > 90%

**回退开关**: `ENABLE_V5_MULTI_STEP=false` 降级为单步执行

---

### 阶段 P4：全量测试与优化（2天）
**目标**: 补全测试覆盖和性能优化
- 异常场景测试（空结果、部分失败、授权拒绝、大数据量、模型异常）
- 基准数据集构建
- 性能优化（缓存策略、并发优化）
- 监控与告警

**验收标准**:
- [ ] 单元测试覆盖率 > 80%
- [ ] 集成测试覆盖 20+ 场景
- [ ] 异常场景测试通过率 100%
- [ ] P95 响应时间 < 5s
- [ ] 监控面板可用（关键指标可视化）
```

#### 6. 可靠性与测试设计

**新增章节**: `9. 可靠性与测试 (Reliability & Testing)`

**内容结构**:
```markdown
## 9. 可靠性与测试

### 9.1 错误分类与处理

#### 9.1.1 错误分类矩阵

| 错误类别 | 错误码 | 重试策略 | 降级策略 | 用户提示 |
|---------|--------|---------|---------|---------|
| 参数错误 | E1xx | 不重试 | 返回错误 | 提示参数问题 |
| 授权错误 | E2xx | 不重试 | 降级公开数据 | 引导授权 |
| 数据源暂时不可用 | E301 | 指数退避 3 次 | 跳过该源 | 提示部分失败 |
| 数据源永久失效 | E302 | 不重试 | 移除该源 | 提示源失效 |
| 容量超限 | E4xx | 不重试 | 启用采样 | 提示数据过大 |
| LLM 超时 | E501 | 线性重试 2 次 | 使用简化 prompt | 提示稍后重试 |
| LLM 输出异常 | E502 | 重试 1 次 | 使用模板输出 | 提示可能不准确 |

#### 9.1.2 重试策略

**指数退避**:
```python
def exponential_backoff(attempt: int) -> float:
    return min(2 ** attempt, 30)  # 最大 30s
```

**线性重试**:
```python
def linear_retry(attempt: int) -> float:
    return attempt * 5  # 5s, 10s, 15s
```

**重试条件**:
- 网络错误: 指数退避 3 次
- 限流错误 (429): 指数退避 5 次
- 服务器错误 (5xx): 线性重试 2 次
- 其他错误: 不重试

#### 9.1.3 幂等性保障

**request_id 机制**:
```python
class ToolCall:
    call_id: str  # 唯一标识符，用于幂等性
    tool_name: str
    args: Dict[str, Any]

# 工具执行前检查
if cache.exists(call.call_id):
    return cache.get(call.call_id)  # 返回缓存结果
```

**幂等性要求**:
- 所有数据查询工具：天然幂等
- 所有数据分析工具：通过 call_id 去重
- 用户交互工具：不保证幂等（每次都弹窗）

#### 9.1.4 超时与速率限制

**超时设置**:
- search_data_sources: 5s
- filter_data: 10s
- fetch_private_data: 30s
- LLM 调用: 60s

**速率限制**:
- 单用户并发：最多 5 个工具并行
- 单数据源 QPS：最多 10 QPS
- LLM 调用频率：最多 20 RPM

### 9.2 测试策略

#### 9.2.1 单元测试

**覆盖目标**: > 80%

**关键测试点**:
- [ ] 每个工具的参数校验
- [ ] 每个工具的正常输出
- [ ] 每个工具的错误处理
- [ ] 授权检查逻辑
- [ ] 数据脱敏逻辑
- [ ] 知识图谱 CRUD
- [ ] 缓存机制

#### 9.2.2 集成测试

**测试场景**:

| 场景分类 | 测试用例 | 预期结果 |
|---------|---------|---------|
| 正向场景 | 查询公开数据源 | 返回结果列表 |
| 正向场景 | 筛选数据（简单条件） | 返回筛选结果 |
| 正向场景 | 对比两个数据集 | 返回差异报告 |
| 空结果场景 | 查询不存在的源 | 返回空列表 + 建议 |
| 空结果场景 | 筛选后无匹配 | 返回空 + 放宽建议 |
| 部分失败场景 | 多源查询 1 个失败 | 返回成功的 + 失败提示 |
| 部分失败场景 | 多步任务中间步骤失败 | 标记失败 + 继续后续 |
| 授权拒绝场景 | 访问私有数据未授权 | E201 + 授权链接 |
| 授权拒绝场景 | Token 过期 | 自动刷新 or E202 |
| 大数据量场景 | filter 返回 10w 行 | 启用采样 + E401 |
| 大数据量场景 | 知识图谱超过 1000 节点 | 拒绝 + E402 |
| 模型异常场景 | Planner 输出非 JSON | 重试 1 次 + E502 |
| 模型异常场景 | Reflector 输出缺少字段 | 使用默认值 + 告警 |
| 并发场景 | 5 个工具并行执行 | 全部成功 |
| 并发场景 | 10 个工具并行（超限） | 排队执行 |

#### 9.2.3 基准数据集

**公开数据集**:
- HackerNews 热门
- GitHub Trending
- RSSHub 热门路由

**私有数据集**:
- 测试账号 B站收藏夹（50 条）
- 测试账号 GitHub Starred（100 条）
- 测试账号笔记库（200 条）

**对比基准**:
- V4.4 相同查询的结果
- 人工标注的正确答案

#### 9.2.4 回归测试

**触发条件**:
- 每次代码提交
- 每次发布前

**测试集**:
- 核心功能测试（20 个用例）
- 异常场景测试（15 个用例）
- 性能基准测试（5 个场景）

**通过标准**:
- 功能测试 100% 通过
- 性能退化 < 10%
```

## 核心场景："把灵感变成科学"

### 场景描述

**用户意图**: "我下期视频想做'AI Agent'"

**期望任务链路**:

1. **扇出 A - 多平台视频搜索**
   - 在 B站、YouTube、抖音上搜索"AI Agent"相关视频
   - 筛选条件：播放量 > 50万
   - 预期结果：20+ 个爆款视频列表

2. **扇出 B - 批量内容提取**
   - 为每个视频生成逐字稿
   - 为每个视频生成摘要
   - 预期结果：20+ 份逐字稿 + 摘要

3. **聚合 C - 结构性对比分析**
   - 对比 20 个爆款的叙事结构
   - 对比 20 个爆款的观点角度
   - 预期结果：结构化的对比报告

4. **聚合 D - 洞察提取**
   - 找出高赞观点的共性（被反复提及的）
   - 找出认知空白（没人提过的切入点）
   - 预期结果：可执行的内容策略建议

### 场景对工具的要求

#### 1. search_data_sources
- 需要支持多平台（B站、YouTube、抖音、小红书、语雀）
- 需要支持筛选条件（播放量、点赞数、发布时间）
- 需要返回结构化元数据（标题、作者、播放量、链接、封面）

#### 2. filter_data
- 需要支持数值筛选（播放量 > 50万）
- 需要支持批量处理（20+ 条数据）
- 需要返回筛选后的完整数据（不仅仅是 ID）

#### 3. extract_insights（新增需求）
- 需要支持视频转逐字稿（调用 Whisper API 或类似服务）
- 需要支持批量摘要生成
- 需要支持结构化提取（叙事结构、观点角度）

#### 4. aggregate_data
- 需要支持语义聚合（找出相似观点）
- 需要支持对比分析（不同视频的差异）
- 需要支持统计分析（高赞观点排名）

#### 5. compare_data
- 需要支持结构化对比（叙事结构的异同）
- 需要支持 Gap 分析（找出认知空白）

### P0 阶段简化方案

**阶段目标**: 验证核心链路，不追求完美

#### 简化策略
1. **平台范围**: 仅支持 B站 + 小红书（2 个平台）
2. **视频处理**: 使用现有 API（B站弹幕 + 简介），暂不做逐字稿
3. **分析深度**: 简单的关键词频率统计，暂不做语义分析
4. **数据量**: 限制单次查询最多 20 条

#### P0 验收标准
- [ ] 可在 B站搜索"AI Agent"并筛选播放量 > 50万
- [ ] 可批量提取视频标题、简介、弹幕
- [ ] 可统计关键词频率（找出高频观点）
- [ ] 可生成简单的对比报告（哪些观点被反复提及）

## 背后思考

### 为什么工具契约如此重要？

工具契约是 Agent 与工具之间的"接口文档"。在 AI Agent 系统中：
- LLM 需要根据契约理解工具能力边界
- Agent 需要根据契约验证工具调用的合法性
- 开发者需要根据契约实现工具逻辑

缺少明确契约会导致：
- Agent 不知道何时该用何种工具
- 工具实现标准不一致
- 边界条件处理遗漏

### 为什么授权与隐私如此关键？

V5.0 引入私有数据访问能力，意味着系统将处理用户的敏感信息：
- B站收藏夹、观看历史
- GitHub 私有仓库
- 个人笔记、书签

任何授权或隐私问题都可能导致：
- 数据泄露风险
- 合规问题
- 用户信任丧失

因此必须在架构设计阶段就考虑周全。

### 为什么知识图谱需要持久化？

当前 V5.0 设计中知识图谱存储在 GraphState 中，这意味着：
- 会话结束后图谱丢失
- 无法跨会话复用数据关系
- 长会话可能导致内存溢出

持久化设计考虑：
- P0 阶段使用内存（快速验证）
- P2 阶段引入 Redis（支持跨会话）
- P3 阶段引入图数据库（支持复杂查询）

### 为什么需要重排阶段目标？

原 V5.0 设计中，compare/aggregate 工具在 P2 阶段才引入，但：
- 对比分析是核心需求（如"对比 HN 和 GitHub Trending"）
- 聚合统计是基础能力（如"统计收藏夹数量"）

应该在 P0/P1 就提供这些能力，确保早期版本可用性。

## TODO 拆解

### 阶段 1: 工具契约规范（预计 2h）✅ 已完成
- [x] 创建任务文档
- [x] 设计工具契约模板（JSON Schema）
- [x] 编写 search_data_sources 完整契约
- [x] 编写 filter_data 完整契约（含分页/采样）
- [x] 编写 fetch_private_data 完整契约
- [x] 编写其他工具契约
- [x] 定义错误码规范
- [x] 更新 V5.0 文档（新增 4.4 章节）

### 阶段 2: 授权与隐私治理（预计 1.5h）✅ 已完成
- [x] 设计 OAuth Token 管理方案
- [x] 设计跨租户数据隔离方案
- [x] 设计敏感数据遮罩规则
- [x] 设计权限拒绝与降级策略
- [x] 定义审计日志要求
- [x] 更新 V5.0 文档（新增 4.5 章节）

### 阶段 3: 知识图谱存储方案（预计 1h）✅ 已完成
- [x] 确定存储介质（内存 -> Redis -> 图数据库）
- [x] 设计容量与 TTL 治理
- [x] 设计并发控制策略
- [x] 设计失败回滚策略
- [x] 说明与 V4.4 兼容性
- [x] 更新 V5.0 文档（修订 6.3.1 章节）

### 阶段 4: 轻量模式语义（预计 0.5h）✅ 已完成
- [x] 明确触发条件
- [x] 定义存储/缓存策略
- [x] 定义可观测性要求
- [x] 定义错误处理流程
- [x] 定义 Planner 协议
- [x] 定义切换条件
- [x] 更新 V5.0 文档（新增 5.2.1 章节）

### 阶段 5: 重排阶段目标（预计 0.5h）✅ 已完成
- [x] 将 compare_data 移至 P0
- [x] 将 aggregate_data 移至 P1
- [x] 为每阶段添加验收标准
- [x] 为每阶段添加回退开关
- [x] 更新 V5.0 文档（修订第 7 章）

### 阶段 6: 可靠性与测试（预计 1.5h）✅ 已完成
- [x] 设计错误分类矩阵
- [x] 定义重试策略
- [x] 定义幂等性保障
- [x] 定义超时与速率限制
- [x] 设计单元测试策略
- [x] 设计集成测试场景（20+ 用例）
- [x] 定义基准数据集
- [x] 定义回归测试要求
- [x] 更新 V5.0 文档（新增第 9 章）

### 阶段 7: 文档整理与索引（预计 0.5h）✅ 已完成
- [x] 更新文档目录
- [x] 检查章节编号一致性
- [x] 验证所有内容已补充完整

## 估时

**总计**: 约 7.5 小时

**分解**:
- 工具契约: 2h
- 授权隐私: 1.5h
- 知识图谱: 1h
- 轻量模式: 0.5h
- 阶段重排: 0.5h
- 可靠性测试: 1.5h
- 文档整理: 0.5h

## 成功标准

- [ ] V5.0 文档包含完整的工具契约规范（11 个工具）
- [ ] V5.0 文档包含完整的授权与隐私治理方案
- [ ] V5.0 文档包含可落地的知识图谱存储方案
- [ ] V5.0 文档明确了轻量模式的语义和切换条件
- [ ] V5.0 文档调整了阶段目标，P0/P1 包含对比和聚合能力
- [ ] V5.0 文档包含完整的可靠性与测试设计（20+ 测试场景）
- [ ] 所有审视意见都有明确的解决方案
